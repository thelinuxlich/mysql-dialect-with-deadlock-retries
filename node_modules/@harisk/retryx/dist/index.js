"use strict";
// src/index.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.retry = retry;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
async function retry(fn, options = {}) {
    const { maxAttempts = 3, delay = 0, backoff = false, timeout, retryOn = () => true, onRetry, } = options;
    let attempt = 0;
    let waitTime = delay;
    while (attempt < maxAttempts) {
        try {
            const result = timeout
                ? await Promise.race([
                    fn(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Retry attempt timed out')), timeout)),
                ])
                : await fn();
            return result;
        }
        catch (err) {
            attempt++;
            if (attempt >= maxAttempts || !retryOn(err)) {
                throw err;
            }
            if (onRetry)
                onRetry(err, attempt);
            if (waitTime > 0)
                await sleep(waitTime);
            if (backoff)
                waitTime *= 2;
        }
    }
    throw new Error('Retry failed after maximum attempts');
}
